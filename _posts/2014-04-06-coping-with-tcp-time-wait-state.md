---
title: TCP TIMEWAIT状态解析1-问题分析
layout: post
permalink: /2014/14/coping-with-tcp-time-wait-state-part-1
date: Sun Apr 6 22:15:56 pm GMT+8 2014
published: true
---
根据TCP的状态转换图，当TCP连接的某一方主动发起连接关闭时，会进入到`TIMEWAIT`状态。关于`TIMEWAIT`状态，有下面几个问题时经常被讨论的，分别是占用可用连接、消耗内存和消耗CPU，这里对这几个问题进行一下分析和说明。

### 占用可用连接
在Linux系统中，一个TCP连接是通过一个四元组来标识的，其中的四个元素分别是*源IP地址*、*源端口*、*目标IP地址*和*目的端口*。在Linux系统中，会在内存中维护一个连接表，用来存储这些四元组，也就是TCP连接。

当一个客户端向一个服务端发起连接时，从客户端的角度来看，这个四元组中只有*源端口*是不确定，因此需要查询内存中的连接表来找到一个可用的端口来发起连接。由于处在`TIMEWAIT`状态的连接不会释放自己的端口，因此如果处在这种状态上的连接过多，就会导致客户端没有可用的端口来发起新的连接，从而无法创建新的连接。

从服务端的角度来看，TCP连接四元组都是确定的，其中*源IP地址*、*源端口*就是自己的IP地址和监听端口，而*目标IP地址*和*目的端口*则是客户端的IP地址和端口。服务端需要做的事情只是拷贝这个四元组，从而在服务端创建一个TCP连接。这个过程如下图所示。

![tcp_create_connection](/images/2014-04/tcp-create-connection.png)

从上面的分析来看，由于处在`TIMEWAIT`状态的连接过多，而导致无法创建新连接的问题只会出现在客户端。

### 消耗内存
由于不管是在客户端还是服务端，Linux内核需要在内存中维护一分内存表，因此处在`TIMEWAIT`状态的进程越多，消耗的内存必然也就越多。处在`TIMEWAIT`状态的连接最多能够消耗掉多少内存其实是可以计算出来的，由于Linux系统规定了连接处在`TIMEWAIT`状态的超时时间，因此我们只要知道在这段时间内处在`TIMEWAIT`状态的连接总数，就可以知道消耗掉的总的内存数。

目前，大多数Linux内核设定的`TIMEWAIT`超时时间是60s，用于保存`TIMEWAIT`状态连接的数据结构大概是150多字节，假设在60s内，有100000个处在`TIMEWAIT`状态的连接，那么将会占用掉150M的内存。由于，客户端还要维护一份当前已经绑定了的端口的数据，而处在`TIMEWAIT`状态的连接也在其中保存有数据，因此需要占用跟多的内存空间。

对于一个每分钟有100000处于`TIMEWAIT`状态的连接的服务器来说，在服务器执行客户端请求，或者向客户端推送数据的过程中消耗的内存是要远远大于`TIMEWAIT`状态连接所消耗的内存的，所以说，内存消耗对服务器来说其实并不是一个太大的问题。

### 消耗CPU
由于只有客户端才需要查询可用端口，因此过多处在`TIMEWAIT`状态的连接对客户端的影响会更大一些。Linux内核在查询可用端口的时候，是需要遍历所有正在使用的连接的，所以是一个CPU密集型的工作。不过，从网上找到的资料来看，虽然这个工作需要加锁和遍历，但是并没有想象中对想能造成很大的影响，而且由于这个工作只发生在客户端，对服务器来说是没有什么影响的。