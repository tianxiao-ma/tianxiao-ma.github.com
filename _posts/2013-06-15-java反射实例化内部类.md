---
title: java反射实例化内部类
layout: post
permalink: /2013/06/java反射实例化内部类/
date: Sat Jun 15 15:53:00 pm GMT+8 2013
published: true
pygments: true
---

内部类的初始化同一般类的初始化基本相同，只是内部类的类名全称有些区别。下面定义了一个Outer类和一个Inner类：
<br />
{% highlight java linenos %}

	publicclassOuter{
	publicclassInner{
	}
	}

{% endhighlight %}

<br />
通过如下方法可以得到Inner类的类名：
<br />
{% highlight java linenos %}

	publicclassOuter{
	publicclassInner{
	}
	publicstaticvoidmain(String[]args){
	System.out.println(Inner.class);
	}
	}

{% endhighlight %}

<br />
从输出结果可以看到，Inner的类名是xxx.xxx.Outer$Inner这种形式的。这是Java中所谓的syntheticname。也就是这个名字在源代码中是找不到对??的文件的，是编译器经过修饰之后的名字。
<br />
反射实例化内部类的代码如下：
<br />
{% highlight java linenos %}

	publicclassOuter{
	publicclassInner{
	}
	publicstaticvoidmain(String[]args){
	System.out.println(Inner.class);
	//查看class是否有构造函数
	System.out.println(Inner.class.getConstructors().length);
	//获取第一个构造函数
	System.out.println(Inner.class.getConstructors()[0]);
	//用构造函数初始化内部类
	System.out.println(Inner.class.getConstructors()[0].newInstance(newOuter());
	}
	}

{% endhighlight %}

<br />
从上面代码的打印输出可以看到，公开非静态内部类的默认构造函数需要一个外围类的实例。
<br />
如果是publicstatic的内部类，则默认构造函数是一个无参的构造函数。如果把Inner类的public关键字去掉，运行上面代码会发现抛错了，因为找不到Inner的构造函???。这个时候只需要将getConstructors方法换成getDeclaredConstructors就可以了。
<br />
如果内部类是私有的，在初始化的时候要将构造函数的访问设置成true。如下：
<br />
{% highlight java linenos %}

	publicclassOuter{
	privateclassInner{
	}
	publicstaticvoidmain(String[]args){
	System.out.println(Inner.class);
	//查看class是否有构造函数
	System.out.println(Inner.class.getDeclaredConstructors().length);
	//获取第一个构造函数
	Constructorc=Inner.class.getDeclaredConstructors()[0];
	//将c设置成可访问
	c.setAccessible(true);
	//用构造函数初始化内部类
	System.out.println(c.newInstance(newOuter());
	}
	}

{% endhighlight %}

<br />
当然，构造类的时候还是要遵循Java的可见性的，比如在其他类里面就没有办法初始化一个类中的私有内部类。

