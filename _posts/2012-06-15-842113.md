---
title: mina概述
layout: post
permalink: /2012/06/mina概述/
date: Fri Jun 15 21:31:15 CST 2012
published: true
pygments: true
---

Apache mina基本上可以看成是一个基于java nio的web通信框架，特点是编程接口简单，但是功能完善，性能也不错。

mina可以提供基于TCP、UDP、符合RS232的顺序通信以及vm内部的基于管道的通信，这些通信方式都以一致的接口暴露，通过接口的不同实现完成。首先来看一下这些接口已经他们之间的交互关系。

主要的接口包括以下几个：

IOService：IOAcceptor和IOConnector的父接口，定义了两者都会用到的一些方法；

IOAcceptor：服务器端需要实现的接口；

IOConnector：客户端需要实现的接口；

IOProcessor：mina内部使用的一个接口，用来管理session，并且利用session来完成具体的io操作

IOSession：每个IOSession都表示一种类型的连接，并且维护��这个链接有关的所有信息。

IOFilter：mina中，发送和接收消息时都需要经过一个过滤器链，这个链用来进行日志记录、编码转换等工作。



这几个接口之间的协作关系如下：

<img src="http://dl.iteye.com/upload/attachment/367531/7f38019e-e5ed-3dc8-b6ee-b93cb28bed8c.png" />


另外还有一个接口，叫做IOHandler，��个接口被注册到IOAcceptor或者IOConnector中，是客户端必须要实现的一个接口，通过这接口里面的方法客户端可以通过mina提供的通信框架发送或者接收网络消息，以及其他的一些事件，比如Session创建等。这个接口接收到的消息是经过IOFilter链过滤过的，通过这个接口发送的消息也需要经过IOFilter链的过滤。读网络上的数据的时候过滤发生在IOProcessor中，而由于写是在IOHandler中直接触发的，所以写的过滤是在IOSession中发生的。



下面简要介绍一下TCP通信方式下，服务器端的启动、绑定和channel建立过程，客户端的连接和channel简历过程大致类似。



TCP的通信涉及到服务器端和客户端，在mina中服务器端使用一个叫做NioSocketAcceptor的类来表示，它继承自AbstractPollingIoAcceptor，从名字可以看出，mina的TCP服务器端实现的基本原理是轮询，在老版本的mina中(也就是netty)中就是这么实现的，只不过由于Java后来有了nio，也就把实现迁移到nio上了。

创建NioSocketAcceptor的时候会创建一个NIOProcessor，这是IOProcessor的一个实现类，这个Processor会被用来管理后续创建的NIOSession。在默认情况下，如果不指定IOProcessor，mina会把这个NIOProcessor在封装一下，变成一个SimpleIoProcessorPool，这个IOProcessor池同时也实现了IOProcessor接口，所以可以被当成IOProcessor来使用，这个是一个Wrapper模式的应用。在SimpleIoProcessorPool内部，会根据IOProcessor的具体类型创建一个或者多个IOProcessor实例，在使用NioSocketAcceptor的时候，就会创建一个或者多个NIOProcessor的实例。这个不是真正意义上的池，因为内部实现是把所有的NIOProcessor放到一个数组中，在有新的NIOSession被创建的时候会从数组中根据NIOSession的id对数组的长度取模，然后拿到一个IOProcessor来处理NIOSession。这些初始化工作完成之后，NioSocketAcceptor就会打开java nio里面的Selector，但是这个时候还没有真正开始接受连接请求，我们需要把这个NioSocketAcceptor绑定到一个具体的地址上。

绑定调用NioSocketAcceptor的bind方法，传入一个或者一组地址。NioSocketAcceptor会启动一个名字叫Acceptor的线程来完成绑定工作。绑定的过程简单来说就��开一个ServerSocketChannel，然后把它与Selector关联起来，用来接收连接请求。这个线程会一直运行，直到被取消绑定为止。每次调用bind方法，都会开这么一个线程，所有的线程都被放到一个线程池里面运行，这个线程池用的是java Executor线程池框架，这些线程池共用一个Selector。

当有新的连接请求过来之��，也就是TCP的客户端调用了NIOSocketConnector的connect方法之后，Acceptor线程会把这个请求转换成一个NIOSession，然后添加到 NIOProcessor中。在默认情况下，Acceptor会首先从SimpleIoProcessorPool里面选取一个NIOProcessor，然后调用这个NIOProcessor的add方法来把NIOSession添加到这个NIOProcessor中。这个过程NIOProcessor会启动一个名叫Processor的线程来处理与这个NIOSession有关的所有IO操作。默认情况下，每个NIOProcessor会用调用Executors.newCachedThreadPool()来创建一个线程池，其中的每个线程都会运行一个Processor，而每个Processor又都会关联到一个NIOSession。这个线程会在通信被服务器端或者客户端主动关闭，或者满足空闲条件的时候被终止。每一个NIOProcessor中管理的Session都共用同一个Selector。

mina支持用一个或者多个线程池来处理所有的IO请求，这个其实是通过设置SimpleProcessorPool里面的IOProcessor数组长���来实现的。因为每一个IOProcessor自己会维护一个线程池来处理所有的IO请求(每一次IO请求就是一个Session)，如果把IOProcessor的数组长度设置成1，就是用一个线程池来处理所有的IO请求，如果大于1，那么就是用多个线程池来处理所有的IO请求。





客户端的处理过程大致类似，也是通过IOProcessor处��和维护所有的IO请求，只不过少了bind这一步操作。
